# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  SSH_USER: root
  SSH_HOST: 213.239.193.208
  DOMAIN: docs.ergoplatform.com
  PROJECT_DIR: /var/www/ergodocs
  PYTHON: python3.11
  JUPYTER_PLATFORM_DIRS: "1"

jobs:
  build:
    name: Build site (no strict) and verify assets
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ runner.os }}-${{ hashFiles('requirements.txt') }}

      - name: Install deps
        shell: bash
        run: |
          set -Eeuo pipefail
          python -m pip install -U pip
          python -m pip install -r requirements.txt

      - name: MkDocs build (no strict; robust logs)
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "‚ùå Build failed; last 200 lines:"; tail -n 200 build.log || true' ERR

          echo "üèó mkdocs build -v"
          mkdocs build -v |& tee build.log
          code=${PIPESTATUS[0]}
          echo "mkdocs exit=$code"
          [ "$code" -eq 0 ] || exit "$code"

          echo "‚ÑπÔ∏è Warning summary (non-fatal)"
          grep -n "WARNING - " build.log || echo "No warnings"

          echo "üîé Smoke-test built site"
          test -s site/index.html || { echo "‚ùå site/index.html missing"; exit 1; }

          JS=$(grep -o 'assets/javascripts/[^"]*' site/index.html | sort -u)
          CSS=$(grep -o 'assets/stylesheets/[^"]*' site/index.html | sort -u)

          echo "JS assets:"; printf "%s\n" $JS
          echo "CSS assets:"; printf "%s\n" $CSS

          FAIL=0
          for f in $JS $CSS; do
            if [ ! -f "site/$f" ]; then
              echo "‚ùå Missing built asset: site/$f"
              FAIL=1
            fi
          done
          [ "$FAIL" -eq 0 ] || exit 1

          printf "%s\n" $JS > artifact_js.txt
          printf "%s\n" $CSS > artifact_css.txt

      - name: Upload build outputs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            build.log
            artifact_js.txt
            artifact_css.txt
            site

  deploy:
    name: Deploy and verify live site
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.DEPLOY_KEY }}
          known_hosts: ${{ secrets.KNOWN_HOSTS }}

      - name: Remote Deploy via SSH (atomic publish + diagnostics)
        shell: bash
        env:
          SSH_USER: ${{ env.SSH_USER }}
          SSH_HOST: ${{ env.SSH_HOST }}
          PROJECT_DIR: ${{ env.PROJECT_DIR }}
          PYTHON: ${{ env.PYTHON }}
          DOMAIN: ${{ env.DOMAIN }}
          JUPYTER_PLATFORM_DIRS: ${{ env.JUPYTER_PLATFORM_DIRS }}
        run: |
          set -Eeuo pipefail
          echo "üöÄ Deploy to $SSH_USER@$SSH_HOST ..."
          # Inject env into the remote process so set -u never sees undefined vars
          ssh "$SSH_USER@$SSH_HOST" \
            "PROJECT_DIR='$PROJECT_DIR' PYTHON='$PYTHON' DOMAIN='$DOMAIN' JUPYTER_PLATFORM_DIRS='${JUPYTER_PLATFORM_DIRS:-1}' bash -s" <<'REMOTE'
            set -Eeuo pipefail

            echo "üîé Effective env"
            echo "PROJECT_DIR=$PROJECT_DIR"
            echo "PYTHON=$PYTHON"
            echo "DOMAIN=$DOMAIN"
            echo "JUPYTER_PLATFORM_DIRS=$JUPYTER_PLATFORM_DIRS"

            echo "üìÇ Confirm project dir"
            cd "$PROJECT_DIR" || { echo "‚ùå cd $PROJECT_DIR failed"; exit 1; }
            pwd
            echo "üóÇ ls -la"
            ls -la

            echo "üîß Toolchain"
            which mkdocs || true
            mkdocs --version || true
            which "$PYTHON" || true
            "$PYTHON" --version || true

            echo "üîÑ Git pull"
            git stash --include-untracked || true
            git pull --rebase

            echo "üêç venv"
            "$PYTHON" -m venv .venv
            source .venv/bin/activate
            python -m pip install -U pip
            python -m pip install -r requirements.txt

            echo "üßº Clean old build dir"
            rm -rf site || true

            echo "üèó mkdocs build -v"
            mkdocs build -v

            echo "üîÅ Atomic swap to site_live"
            rm -rf site_next && mv site site_next
            rm -rf site_prev || true
            if [ -d site_live ]; then mv site_live site_prev; fi
            mv site_next site_live
            ln -sfn site_live site

            echo "üëÄ Path sanity"
            echo "site symlink -> $(readlink -f site || true)"
            find site_live -maxdepth 2 -type d -printf "%p\n" | head -n 20

            echo "üîë Ownership and perms"
            id || true
            if id www-data >/dev/null 2>&1; then chown -R www-data:www-data site_live || true; fi
            if id caddy >/dev/null 2>&1; then chown -R caddy:caddy site_live || true; fi
            find site_live -maxdepth 2 -type d -printf "%M %u:%g %p\n" | head -n 10

            echo "üß© Web server detection"
            if command -v nginx >/dev/null 2>&1; then
              echo "üåê Nginx present"
              nginx -v || true
              echo "üß™ nginx -t"
              nginx -t || { echo "‚ùå nginx -t failed"; exit 1; }
              echo "üìÑ nginx -T (first 200 lines)"
              nginx -T | sed -n '1,200p'
              echo "üîé server block grep for $DOMAIN"
              nginx -T | grep -A3 -B3 -n "server_name.*$DOMAIN" || true
              echo "üîÅ Reload Nginx"
              systemctl reload nginx || true
              echo "üóí nginx status (tail)"
              systemctl status nginx --no-pager -l | tail -n 50 || true
            elif command -v caddy >/dev/null 2>&1; then
              echo "üåê Caddy present"
              caddy version || true
              echo "üìÑ Caddyfile (first 200 lines)"
              if [ -f /etc/caddy/Caddyfile ]; then sed -n '1,200p' /etc/caddy/Caddyfile; fi
              echo "üîÅ Reload Caddy"
              systemctl reload caddy || true
              echo "üóí caddy status (tail)"
              systemctl status caddy --no-pager -l | tail -n 50 || true
            else
              echo "‚ÑπÔ∏è No nginx or caddy found in PATH"
            fi

            echo "üîç Local HTTP sanity"
            curl -s -I http://127.0.0.1/ | sed -n '1,20p' || true
            echo "üîç Top of built /index.html"
            test -f site_live/index.html && head -n 5 site_live/index.html || true

      - name: Verify Remote Site Files
        shell: bash
        env:
          SSH_USER: ${{ env.SSH_USER }}
          SSH_HOST: ${{ env.SSH_HOST }}
          PROJECT_DIR: ${{ env.PROJECT_DIR }}
        run: |
          echo "üîç Recently updated files on server"
          ssh "$SSH_USER@$SSH_HOST" "find '$PROJECT_DIR/site' -type f -printf 'üïí %TY-%Tm-%Td %TH:%TM:%TS %p\n' | sort -r | head -n 12 || true"

      - name: Verify HTML and assets served (no-cache)
        shell: bash
        env:
          DOMAIN: ${{ env.DOMAIN }}
        run: |
          set -Eeuo pipefail
          BASE="https://${DOMAIN}"

          echo "üîé Fetch live homepage HTML"
          curl -fsS -H 'Cache-Control: no-cache' "$BASE/" > /tmp/home.html

          grep -q "</html>" /tmp/home.html || { echo "‚ùå Live HTML incomplete"; exit 1; }

          echo "üîé Extract asset URLs from live HTML"
          LIVE_JS=$(grep -o 'assets/javascripts/[^"]*' /tmp/home.html | sort -u)
          LIVE_CSS=$(grep -o 'assets/stylesheets/[^"]*' /tmp/home.html | sort -u)

          echo "‚úÖ Check each asset returns 200"
          FAIL=0
          for f in $LIVE_JS $LIVE_CSS; do
            url="$BASE/$f"
            code=$(curl -s -o /dev/null -w "%{http_code}" "$url")
            echo "$code $url"
            [ "$code" = "200" ] || FAIL=1
          done
          [ "$FAIL" -eq 0 ] || { echo "‚ùå One or more assets failed to serve 200 (possible blank page)"; exit 1; }

          echo "üß™ Smoke-check a content page"
          curl -fsS -H 'Cache-Control: no-cache' "$BASE/faq/" | grep -q "</html>" || { echo "‚ùå FAQ page did not return valid HTML"; exit 1; }

      - name: Show cache headers for HTML vs assets
        shell: bash
        env:
          DOMAIN: ${{ env.DOMAIN }}
        run: |
          set -Eeuo pipefail
          BASE="https://${DOMAIN}"
          echo "# HTML headers"
          curl -s -I -H 'Cache-Control: no-cache' "$BASE/" | sed -n '1,25p'
          echo "# Asset headers (pick first js/css)"
          js=$(curl -s "$BASE/" | grep -o 'assets/javascripts/[^"]*' | head -n1 || true)
          css=$(curl -s "$BASE/" | grep -o 'assets/stylesheets/[^"]*' | head -n1 || true)
          if [ -n "$js" ]; then curl -s -I "$BASE/$js" | sed -n '1,25p'; fi
          if [ -n "$css" ]; then curl -s -I "$BASE/$css" | sed -n '1,25p'; fi
